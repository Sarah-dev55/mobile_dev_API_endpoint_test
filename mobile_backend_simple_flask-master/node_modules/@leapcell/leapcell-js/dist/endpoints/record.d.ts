import { Context, TableMeta, NameType } from "../types";
type RecordValueType = string | number | null | string[];
export interface Record {
    fields: {
        [fieldId: string]: RecordValueType;
    };
    record_id: string;
    create_time: number;
    update_time: number;
}
export interface RecordList {
    records: Record[];
}
export interface RecordItem {
    record: Record;
}
export interface Metric {
    aggr: string;
    condition?: string;
    field: string;
}
export interface MetricData extends Metric {
    value: number;
}
export interface MetricDataList {
    metrics?: MetricData[];
    metric?: MetricData;
}
type UpdateRecord = Record["fields"];
interface RecordOrderByQuery {
    [fieldName: string]: "asc" | "desc";
}
interface RecordSelectQuery {
    fields?: string[];
    offset?: number;
    limit?: number;
}
type FieldWhereQuery = {
    gt: any;
} | {
    gte: any;
} | {
    neq: any;
} | {
    lt: any;
} | {
    eq: any;
} | {
    lte: any;
} | {
    in: any;
} | {
    not_in: any;
} | {
    is_null: never;
} | {
    not_null: never;
} | {
    contain: any;
};
interface NormalWhereQuery {
    [fieldName: string]: FieldWhereQuery;
}
export interface RecordSearchQuery {
    fields: string[];
    search_fields: string[];
    query: string;
    offset?: number;
    limit?: number;
    boostFields?: {
        [fieldName: string]: number;
    };
    filter?: ServerFilter;
    order?: ServerOrderByItem;
    orders?: ServerOrderByItem[];
    name_type: NameType;
}
export interface RecordSearchQueryParams {
    where?: RecordWhereQuery;
    orderBy?: RecordOrderByQuery;
    select?: RecordSelectQuery;
    search_fields?: string[];
    query: string;
    offset?: number;
    limit?: number;
    boostFields?: {
        [fieldName: string]: number;
    };
}
export interface ANDWhereQuery {
    AND: RecordWhereQuery | RecordWhereQuery[];
}
export interface ORWhereQuery {
    OR: RecordWhereQuery[] | RecordWhereQuery;
}
export interface NotWhereQuery {
    NOT: RecordWhereQuery;
}
export type RecordWhereQuery = NormalWhereQuery | ANDWhereQuery | ORWhereQuery | NotWhereQuery;
export type RecordWhereQueryContent = FieldWhereQuery | RecordWhereQuery | RecordWhereQuery[];
interface ServerNormalFilter {
    val: RecordValueType;
    op: "gt" | "gte" | "neq" | "lt" | "eq" | "lte" | "in" | "not_in" | "contain" | "is_null" | "not_null";
    field: string;
    filter_type: "single";
}
interface ServerGroupFilter {
    filters: ServerFilter[];
    filter_type: "and" | "or" | "not";
}
type ServerFilter = ServerNormalFilter | ServerGroupFilter;
interface ServerOrderByItem {
    field: string;
    order_by: "asc" | "desc";
}
export declare class RecordsEndpoint {
    #private;
    constructor(context: Context, tableMeta: TableMeta);
    /**
     * @description Find a record by id
     * @example
     * ```ts
     * const record = await api.repos('repoId').table('tableId').records.findById('recordId');
     * ```
     * @param id: string, the id of the record
     * @returns Record
     */
    findById(id: string): Promise<Record>;
    /**
     * @description Find multiple records
     * @example
     * ```ts
     * const records = await api.repos('repoId').table('tableId').records.findMany({
     * where: {
     *  AND: {
     *   field1: { gt: 1 },
     *  field2: { lt: 2 },
     * },
     * orderBy: {
     * field1: 'asc',
     * field2: 'desc',
     * },
     * select: {
     * field1: true,
     * field2: true,
     * },
     * });
     * ```
     * @param param.where: RecordWhereQuery, the where query
     * @param param.orderBy: RecordOrderByQuery, the order by query
     * @param param.select: RecordSelectQuery, the select query
     * @returns Record[]
     * @throws ApiError
     * @memberof RecordsEndpoint
     * @throws {ApiError}
     */
    findMany(param?: {
        where?: RecordWhereQuery;
        orderBy?: RecordOrderByQuery;
        select?: RecordSelectQuery;
        skip?: number;
        take?: number;
    }): Promise<Record[]>;
    /**
     * @description get count of records
     * @example
     * ```ts
     * const count = await api.repos('repoId').table('tableId').records.count({
     * where: {
     * AND: {
     * field1: { gt: 1 },
     * field2: { lt: 2 },
     * },
     * distinct: true,
     * });
     * ```
     * @param param.where: RecordWhereQuery, the where query
     * @param param.distinct: boolean, whether to count distinct records
     * @returns number
     */
    count(param?: {
        where?: RecordWhereQuery;
        distinct?: boolean;
    }): Promise<number>;
    first(param: {
        where?: RecordWhereQuery;
        orderBy?: RecordOrderByQuery;
        select?: RecordSelectQuery;
    }): Promise<Record | null>;
    create(record: UpdateRecord): Promise<any>;
    createMany(records: UpdateRecord[]): Promise<any>;
    updateById(param: {
        id: string;
        data: UpdateRecord;
    }): Promise<void>;
    updateMany(param: {
        where?: RecordWhereQuery;
        data: UpdateRecord;
    }): Promise<void>;
    deleteById(id: string): Promise<void>;
    deleteMany(param: {
        where?: RecordWhereQuery;
    }): Promise<void>;
    /**
     * @description search multiple records
     * ```
     * @param param: RecordSearchQuery, the where query
     * @returns Record[]
     * @throws ApiError
     * @memberof RecordsEndpoint
     * @throws {ApiError}
     */
    search(param: RecordSearchQueryParams): Promise<Record[]>;
}
export {};
