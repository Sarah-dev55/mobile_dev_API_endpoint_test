var M = (s, t, e) => {
  if (!t.has(s))
    throw TypeError("Cannot " + e);
};
var r = (s, t, e) => (M(s, t, "read from private field"), e ? e.call(s) : t.get(s)), a = (s, t, e) => {
  if (t.has(s))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(s) : t.set(s, e);
}, o = (s, t, e, i) => (M(s, t, "write to private field"), i ? i.call(s, e) : t.set(s, e), e);
var l = (s, t, e) => (M(s, t, "access private method"), e);
import Q from "axios";
import C from "form-data";
const u = (s) => {
  var t, e;
  if (s.status !== 200) {
    const i = (t = s.data) == null ? void 0 : t.code, n = (e = s.data) == null ? void 0 : e.error;
    throw Error(
      i && n ? `invalid response status: ${s.status}, error code ${i}, hint: ${n}` : `invalid response status: ${s.status}`
    );
  }
  return !0;
}, V = (s) => s !== null && typeof s == "object", W = (s, t) => {
  if (s !== "AND" && s !== "OR" && s !== "NOT")
    return !0;
  for (const e in t)
    if (V(t[e]))
      return !1;
  return !0;
}, z = (s, t) => s === "OR" && Array.isArray(t), J = (s, t) => s === "AND" && !W(s, t), G = (s, t) => s === "NOT" && Array.isArray(t), g = (s, t) => J(s, t) ? {
  filter_type: "and",
  filters: Object.entries(t).map(([e, i]) => g(
    e,
    i
  ))
} : z(s, t) ? {
  filter_type: "or",
  filters: t.map((e) => g("AND", e))
} : G(s, t) ? {
  filter_type: "not",
  filters: t.map((e) => g("AND", e))
} : {
  filter_type: "single",
  field: s,
  op: Object.keys(t)[0],
  val: Object.values(t)[0]
}, w = (s) => {
  if (!s)
    return null;
  const t = Object.keys(s);
  if (t.length < 1)
    return null;
  if (t.length > 1)
    return g("AND", s);
  const e = t[0], i = s[e];
  return g(e, i);
}, R = (s) => {
  if (!s)
    return null;
  const t = [];
  for (const e in s)
    t.push({
      field: e,
      order_by: s[e]
    });
  return t.length < 1 ? null : t.length === 1 ? { order: t[0] } : { orders: t };
};
var d, c, h, y;
class H {
  constructor(t, e) {
    a(this, h);
    a(this, d, void 0);
    a(this, c, void 0);
    o(this, d, t), o(this, c, e);
  }
  /**
   * @description Find a record by id
   * @example
   * ```ts
   * const record = await api.repos('repoId').table('tableId').records.findById('recordId');
   * ```
   * @param id: string, the id of the record
   * @returns Record
   */
  async findById(t) {
    const e = await r(this, d).axios.get(
      `${l(this, h, y).call(this)}/record/${t}`,
      {
        params: {
          name_type: r(this, c).nameType
        }
      }
    );
    return u(e), e.data.data.record;
  }
  /**
   * @description Find multiple records
   * @example
   * ```ts
   * const records = await api.repos('repoId').table('tableId').records.findMany({
   * where: {
   *  AND: {
   *   field1: { gt: 1 },
   *  field2: { lt: 2 },
   * },
   * orderBy: {
   * field1: 'asc',
   * field2: 'desc',
   * },
   * select: {
   * field1: true,
   * field2: true,
   * },
   * });
   * ```
   * @param param.where: RecordWhereQuery, the where query
   * @param param.orderBy: RecordOrderByQuery, the order by query
   * @param param.select: RecordSelectQuery, the select query
   * @returns Record[]
   * @throws ApiError
   * @memberof RecordsEndpoint
   * @throws {ApiError}
   */
  async findMany(t) {
    t || (t = {});
    let e = {
      ...t.select,
      name_type: r(this, c).nameType
    };
    const i = w(t.where);
    i && (e.filter = i);
    const n = R(t.orderBy);
    n && (e = { ...e, ...n });
    const f = await r(this, d).axios.post(
      `${l(this, h, y).call(this)}/record/query`,
      e
    );
    return u(f), f.data.data.records;
  }
  /**
   * @description get count of records
   * @example
   * ```ts
   * const count = await api.repos('repoId').table('tableId').records.count({
   * where: {
   * AND: {
   * field1: { gt: 1 },
   * field2: { lt: 2 },
   * },
   * distinct: true,
   * });
   * ```
   * @param param.where: RecordWhereQuery, the where query
   * @param param.distinct: boolean, whether to count distinct records
   * @returns number
   */
  async count(t) {
    var n;
    let e = { name_type: r(this, c).nameType };
    if (e = {
      ...e,
      metric: {
        aggr: "count",
        field: "*"
      }
    }, t) {
      if (t.where) {
        const f = w(t.where);
        f && (e.filter = f);
      }
      t.distinct && (e.metric = {
        aggr: "count",
        field: "*",
        condition: "distinct"
      });
    }
    const i = await r(this, d).axios.post(
      `${l(this, h, y).call(this)}/record/metrics`,
      e
    );
    return u(i), ((n = i.data.data.metric) == null ? void 0 : n.value) || 0;
  }
  async first(t) {
    let e = {
      ...t.select,
      name_type: r(this, c).nameType
    };
    const i = w(t.where);
    i && (e.filter = i);
    const n = R(t.orderBy);
    n && (e = { ...e, ...n }), e = {
      ...e,
      limit: 1
    };
    const f = await r(this, d).axios.post(
      `${l(this, h, y).call(this)}/record/query`,
      e
    );
    return u(f), f.data.data[0] ? f.data.data[0] : null;
  }
  async create(t) {
    const e = await r(this, d).axios.post(`${l(this, h, y).call(this)}/record`, {
      record: t,
      name_type: r(this, c).nameType
    });
    return u(e), e.data.data;
  }
  async createMany(t) {
    const e = await r(this, d).axios.post(`${l(this, h, y).call(this)}/record`, {
      records: t,
      name_type: r(this, c).nameType
    });
    return u(e), e.data.data;
  }
  async updateById(t) {
    const e = await r(this, d).axios.put(
      `${l(this, h, y).call(this)}/record/${t.id}`,
      {
        fields: t.data,
        name_type: r(this, c).nameType
      }
    );
    return u(e), e.data.data;
  }
  async updateMany(t) {
    const e = {
      fields: t.data,
      name_type: r(this, c).nameType
    }, i = w(t.where);
    i && (e.filter = i);
    const n = await r(this, d).axios.put(
      `${l(this, h, y).call(this)}/record`,
      e
    );
    return u(n), n.data;
  }
  async deleteById(t) {
    const e = await r(this, d).axios.delete(
      `${l(this, h, y).call(this)}/record/${t}`
    );
    return u(e), e.data;
  }
  async deleteMany(t) {
    const e = {
      name_type: r(this, c).nameType
    }, i = w(t.where);
    i && (e.filter = i);
    const n = await r(this, d).axios.delete(
      `${l(this, h, y).call(this)}/record`,
      { data: e }
    );
    return u(n), n.data;
  }
  /**
   * @description search multiple records
   * ```
   * @param param: RecordSearchQuery, the where query
   * @returns Record[]
   * @throws ApiError
   * @memberof RecordsEndpoint
   * @throws {ApiError}
   */
  async search(t) {
    var U;
    let e = {
      name_type: r(this, c).nameType,
      search_fields: t.search_fields || [],
      offset: t.offset,
      limit: t.limit,
      boostFields: t.boostFields,
      query: t.query,
      fields: ((U = t.select) == null ? void 0 : U.fields) || []
    };
    const i = w(t.where);
    i && (e.filter = i);
    const n = R(t.orderBy);
    n && (e = { ...e, ...n });
    const f = await r(this, d).axios.post(
      `${l(this, h, y).call(this)}/record/search`,
      e
    );
    return u(f), f.data.data.records;
  }
}
d = new WeakMap(), c = new WeakMap(), h = new WeakSet(), y = function() {
  return `/${r(this, c).resource}/table/${r(this, c).tableId}`;
};
var N, q;
class P {
  constructor(t, e) {
    a(this, N, void 0);
    a(this, q, void 0);
    o(this, N, t), o(this, q, e);
  }
}
N = new WeakMap(), q = new WeakMap();
var _, b, B, K;
class X {
  constructor(t, e) {
    a(this, B);
    a(this, _, void 0);
    a(this, b, void 0);
    o(this, _, t), o(this, b, e);
  }
  async upload(t) {
    const e = new C();
    e.append("file", t, {
      filename: "file"
    });
    const i = await r(this, _).axios.post(
      `${l(this, B, K).call(this)}/upload`,
      e,
      {
        headers: {
          "Content-Type": "multipart/form-data"
        }
      }
    );
    return u(i), i.data.data;
  }
}
_ = new WeakMap(), b = new WeakMap(), B = new WeakSet(), K = function() {
  return `/${r(this, b).resource}/table/${r(this, b).tableId}`;
};
var F;
class k {
  constructor(t) {
    a(this, F, void 0);
    o(this, F, t);
  }
  static createInst(t, e) {
    return new Y(t, e);
  }
}
F = new WeakMap();
var m, p, T, v, A;
class Y {
  constructor(t, e) {
    a(this, m, void 0);
    a(this, p, void 0);
    a(this, T, void 0);
    a(this, v, void 0);
    a(this, A, void 0);
    o(this, m, t), o(this, p, e);
  }
  /**
   * @example
   * ```ts
   * const metadata = await api.repos('repoId').table('tableId').getMetadata();
   * ```
   * @returns {Promise<TableMetadata>}
   * @memberof Table
   * @throws {ApiError}
   */
  async meta() {
    const t = await r(this, m).axios.get(
      `/${r(this, p).resource}/table/${r(this, p).tableId}`,
      {
        params: {
          name_type: r(this, p).nameType
        }
      }
    );
    return u(t), t.data.data;
  }
  get records() {
    return r(this, T) || o(this, T, new H(r(this, m), r(this, p)));
  }
  get file() {
    return r(this, v) || o(this, v, new X(r(this, m), r(this, p)));
  }
  get fields() {
    return r(this, A) || o(this, A, new P(r(this, m), r(this, p)));
  }
}
m = new WeakMap(), p = new WeakMap(), T = new WeakMap(), v = new WeakMap(), A = new WeakMap();
var j;
class S {
  constructor(t) {
    a(this, j, void 0);
    o(this, j, t);
  }
  static createInst(t, e) {
    return new Z(t, e);
  }
}
j = new WeakMap();
var x, I, O;
class Z {
  constructor(t, e) {
    a(this, x, void 0);
    a(this, I, void 0);
    a(this, O, void 0);
    o(this, x, t), o(this, I, e);
  }
  get tables() {
    return r(this, O) || o(this, O, new k(r(this, x)));
  }
  /**
   * @example
   * ```ts
   * const table = api.repos('repoId').table('tableId');
   * ```
   * @param {string} tableId - The id of the table
   * @param {NameType} nameType - The type of the name to use, either 'id' or 'name'
   * @returns {TablesEndpoint}
   * @memberof LeapcellApi
   */
  table(t, e = "name") {
    return k.createInst(r(this, x), { ...r(this, I), tableId: t, nameType: e });
  }
}
x = new WeakMap(), I = new WeakMap(), O = new WeakMap();
const tt = "0.0.1";
var $, E, L, D;
class it {
  //TODO: use default?
  constructor(t) {
    a(this, E);
    a(this, $, void 0);
    a(this, D, void 0);
    const i = { ...{
      endpoint: "https://api.leapcell.io"
    }, ...t };
    o(this, $, {
      token: i.apiKey,
      axios: l(this, E, L).call(this, i)
    });
  }
  get repos() {
    return r(this, D) || o(this, D, new S(r(this, $)));
  }
  /**
   * @example
   * ```ts
   * const repo =  api.repo('owner', 'repoName')
   * ```
   * @param {string} owner - The owner of the repo
   * @param {string} repoName - The name of the repo
   * @returns {ReposEndpoint}
   * @memberof LeapcellApi
   *
   */
  repo(t) {
    return S.createInst(r(this, $), { resource: t });
  }
  /**
  * @example
  * ```ts
  * const repo =  api.project('owner', 'repoName')
  * ```
  * @param {string} owner - The owner of the repo
  * @param {string} repoName - The name of the repo
  * @returns {ReposEndpoint}
  * @memberof LeapcellApi
  *
  */
  project(t) {
    return S.createInst(r(this, $), { resource: t });
  }
}
$ = new WeakMap(), E = new WeakSet(), L = function(t) {
  return Q.create({
    headers: {
      Authorization: `Bearer ${t.apiKey}`,
      "User-Agent": `Leapcell Javascript-Client/${tt}`
    },
    baseURL: `${t.endpoint}/api/v1`,
    validateStatus: () => !0
  });
}, D = new WeakMap();
export {
  it as Leapcell
};
